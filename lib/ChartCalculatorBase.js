// Generated by CoffeeScript 1.3.3

/*
The general structure of an incrementally update-able visualization follows these steps:

1. Gather the parameters you'll need to specify the visualization
   a. Gather some info from Rally's standard WSAPI
   b. Gather some info from the user.

2. Create a hash from info from above to be used as the key for cache lookup.

3. Restore the cached calculation using LocalCache.

4. Render the cached calculation. Leave space for updates on the x-axis. Show spinners for missing parts.

5. Query the Lookback API for the incremental "snapshots" not found in the cache.
   Get one page's worth of updates. Maybe 10,000 snapshots max?

6. Update the calculation/manipulation/aggregation of the snapshot data.

7. Update the chart.

8. If there are still more pages of snapshots to update repeat starting at step 5.
*/


(function() {
  var ChartCalculatorBase, lumenize, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/Lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils;

  ChartCalculatorBase = (function() {
    /*
      @class ChartCalculatorBase
        This is intended to the be the base class for ChartCalculators. It assumes a template method pattern where the parts
        of the algorithm that have to do with saving to and restoring from the LocalCache (using localStorage API) and
        providing events for config changes or data updates.
    
        You must override these methods:
          * initialize() - set @LumenizeCalculatorClass (implements Lumenize.iCalculator)
    
        You may wish to override:
          * deriveFields(snapshots)
    
      @cfg {Number} [refreshIntervalMilliseconds = 5 * 60 * 1000]
    
      @property {Object} userConfig Useful for creating the cache hash. The contents of this will be ChartCalculator specific
    
      @property {Object} config Starts with all the values in userConfig but more may be added
      @property {Number} [config.refreshIntervalMilliseconds = 5 * 60 * 1000] The chart will automatically refresh after this many milliseconds
      @property {Object} [config.deriveFieldsConfig] If you include this, it will pass it into Lumenize.deriveFields as the config Object every time it gets new snapshots to process.
      @property {Boolean} [config.debug = false]
      @property {Object} config.lumenizeCalculatorConfig The config that will be passed to the Lumenize calculator upon instantiation. Do not put x-axis range info in here.
    
      @property {Object} projectAndWorkspaceScope
      @property {Number} projectAndWorkspaceScope.workspaceOID
      @property {Boolean} projectAndWorkspaceScope.projectScopingUp
      @property {Boolean} projectAndWorkspaceScope.projectScopingDown
      @property {Number} projectAndWorkspaceScope.projectOID
    
      @property {Object} workspaceConfiguration Has whatever fields come from Rally but WorkDays and TimeZone (note Caps) are often used by calculators
    
      @property {Lumenize.iCalculator} LumenizeCalculatorClass Must be set; typically in your initialize() method
    
      @property {Object} visualizationData This is where you store the data that you want to communicate to your visualizations.
        It will be passed into visualizationCreateCB and visualizationUpdateCB.
    
      @property {iAnalyticsQuery} analyticsQuery Instantiate this in your onNewDataAvailable() method.
    
      @property {String} upToDate A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the last moment that this chart is
        up to date. You should not set this but you can read from it. It will be set when new snapshots are added or it's
        restored from the cache.
      @readonly
    */

    function ChartCalculatorBase(visualizations, userConfig, createVisualizationCB) {
      this.visualizations = visualizations;
      this.userConfig = userConfig;
      this.createVisualizationCB = createVisualizationCB;
      this.onSnapshotsReceieved = __bind(this.onSnapshotsReceieved, this);

      /*
          You should not have a constructor for the sub-class. Rather, put your code in initialize(). If for some crazy
          reason you really want a constructor, make sure it looks like this:
          ```
          constructor: (myCustomArgument, remainingArguments...) ->
            # Any code you want to execute before initialize(). Use myCustomArgument.
            super(remainingArguments...)
            # Any code you want to execute after initialize(). Use myCustomArgument.
          ```
      */

      this.config = utils.clone(this.userConfig);
      this.timeoutHandle = null;
      this.cache = new LocalCache();
      if (this.config.debug == null) {
        this.config.debug = false;
      }
      this.getProjectAndWorkspaceScope();
    }

    ChartCalculatorBase.prototype.getProjectAndWorkspaceScope = function() {
      var projectOID, projectScopingDown, projectScopingUp, scope, workspaceOID, _callback,
        _this = this;
      if (top === self) {
        workspaceOID = 41529001;
        projectScopingUp = false;
        projectScopingDown = true;
        projectOID = 81147451;
      } else {
        workspaceOID = __WORKSPACE_OID__;
        projectScopingUp = __PROJECT_SCOPING_UP__;
        projectScopingDown = __PROJECT_SCOPING_DOWN__;
        projectOID = __PROJECT_OID__;
      }
      scope = {
        workspaceOID: workspaceOID,
        projectScopingUp: projectScopingUp,
        projectScopingDown: projectScopingDown,
        projectOID: projectOID
      };
      _callback = function(projectAndWorkspaceScope) {
        _this.projectAndWorkspaceScope = projectAndWorkspaceScope;
        return _this.getWorkspaceConfiguration();
      };
      return _callback(scope);
    };

    ChartCalculatorBase.prototype.getWorkspaceConfiguration = function() {
      var workspaceConfiguration, _callback,
        _this = this;
      workspaceConfiguration = {
        DateFormat: 'MM/dd/yyyy',
        DateTimeFormat: 'MM/dd/yyyy hh:mm:ss a',
        IterationEstimateUnitName: 'Points',
        ReleaseEstimateUnitName: 'Points',
        TaskUnitName: 'Hours',
        TimeTrackerEnabled: true,
        TimeZone: 'America/Denver',
        WorkDays: 'Monday,Tuesday,Wednesday,Thursday,Friday'
      };
      _callback = function(workspaceConfiguration) {
        _this.workspaceConfiguration = workspaceConfiguration;
        _this.initialize();
        return _this.onConfigOrScopeUpdated();
      };
      return _callback(workspaceConfiguration);
    };

    ChartCalculatorBase.prototype.onConfigOrScopeUpdated = function() {
      var savedState;
      savedState = this.cache.getItem(this.getHashForCache());
      if (savedState != null) {
        this.lumenizeCalculator = this.LumenizeCalculatorClass.newFromSavedState(savedState);
        this.upToDate = this.lumenizeCalculator.upToDate;
      } else {
        this.lumenizeCalculator = new this.LumenizeCalculatorClass(this.config.lumenizeCalculatorConfig);
        this.upToDate = null;
      }
      this.createOrUpdateVisualization();
      return this.onNewDataAvailable();
    };

    ChartCalculatorBase.prototype.onSnapshotsReceieved = function(snapshots, startOn, endBefore, queryInstance) {
      if (queryInstance == null) {
        queryInstance = null;
      }
      if (snapshots.length > 0) {
        this.dirty = true;
      } else {
        this.dirty = false;
      }
      this.lastQueryReceivedMilliseconds = new Date().getTime();
      this.upToDate = endBefore;
      this.deriveFields(snapshots);
      this.updateCalculator(snapshots, startOn, endBefore);
      this.createOrUpdateVisualization();
      if (this.analyticsQuery.hasMorePages()) {
        return this.onNewDataAvailable();
      } else {
        return this.newDataExpected(void 0, this.config.refreshIntervalMilliseconds);
      }
    };

    ChartCalculatorBase.prototype.newDataExpected = function(paddingDelay, etlDelay) {
      var delay;
      if (paddingDelay == null) {
        paddingDelay = 30 * 1000;
      }
      if (etlDelay == null) {
        etlDelay = 5 * 60 * 1000;
      }
      delay = etlDelay + paddingDelay;
      if (this.timeoutHandle != null) {
        clearTimeout(this.timeoutHandle);
      }
      return this.timeoutHandle = setTimeout(this.onNewDataAvailable, delay);
    };

    ChartCalculatorBase.prototype.removeFromCacheAndRecalculate = function() {
      this.upToDate = null;
      this.cache.removeItem(this.getHashForCache());
      return this.onConfigOrScopeUpdated();
    };

    ChartCalculatorBase.prototype.updateCalculator = function(snapshots, startOn, endBefore) {
      /*
          @method updateCalculator
            Allows you to incrementally add snapshots to this calculator. It will also update the cache.
          @param {Object[]} snapshots An array of temporal data model snapshots.
          @param {String} startOn A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the time start of the period of
            interest. On the second through nth call, this must equal the previous endBefore.
          @param {String} endBefore A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the moment just past the time
            period of interest. This should be the ETLDate from the results of your query to the Lookback API.
      */

      var savedState;
      this.lumenizeCalculator.addSnapshots(snapshots, startOn, endBefore);
      savedState = this.lumenizeCalculator.getStateForSaving();
      return this.cache.setItem(this.getHashForCache(), savedState);
    };

    ChartCalculatorBase.prototype.initialize = function() {
      if (this.config.lumenizeCalculatorConfig == null) {
        this.config.lumenizeCalculatorConfig = {};
      }
      this.config.lumenizeCalculatorConfig.workDays = this.workspaceConfiguration.WorkDays;
      if (this.userConfig.tz != null) {
        return this.config.lumenizeCalculatorConfig.tz = this.userConfig.tz;
      } else {
        return this.config.lumenizeCalculatorConfig.tz = this.workspaceConfiguration.TimeZone;
      }
    };

    ChartCalculatorBase.prototype.deriveFields = function(snapshots) {
      if (this.config.deriveFieldsConfig != null) {
        return Lumenize.deriveFields(snapshots, this.config.deriveFieldsConfig);
      }
    };

    ChartCalculatorBase.prototype.onNewDataAvailable = function() {
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    ChartCalculatorBase.prototype.createOrUpdateVisualization = function() {};

    ChartCalculatorBase.prototype.getHashForCache = function() {};

    return ChartCalculatorBase;

  })();

  this.ChartCalculatorBase = ChartCalculatorBase;

}).call(this);
