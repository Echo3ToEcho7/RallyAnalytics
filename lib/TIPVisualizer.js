// Generated by CoffeeScript 1.3.3
(function() {
  var TIPVisualizer, lumenize, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils;

  TIPVisualizer = (function(_super) {

    __extends(TIPVisualizer, _super);

    function TIPVisualizer() {
      this.onNewDataAvailable = __bind(this.onNewDataAvailable, this);
      return TIPVisualizer.__super__.constructor.apply(this, arguments);
    }

    /*
    */


    TIPVisualizer.prototype.initialize = function() {
      var field, s, trackLastValueForTheseFields, _i, _len, _ref, _ref1;
      if (this.config.trace) {
        console.log('in TIPVisualizer.initialize');
      }
      TIPVisualizer.__super__.initialize.call(this);
      this.config.toolTipFieldNames = [];
      _ref = this.config.showTheseFieldsInToolTip;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (utils.type(s) === 'string') {
          field = s;
        } else {
          field = s.field;
        }
        this.config.toolTipFieldNames.push(field);
      }
      trackLastValueForTheseFields = ['_ValidTo'].concat(this.config.toolTipFieldNames);
      if (_ref1 = this.config.radiusField.field, __indexOf.call(trackLastValueForTheseFields, _ref1) < 0) {
        trackLastValueForTheseFields.push(this.config.radiusField.field);
      }
      this.config.lumenizeCalculatorConfig.trackLastValueForTheseFields = trackLastValueForTheseFields;
      this.config.lumenizeCalculatorConfig.granularity = 'hour';
      this.config.lumenizeCalculatorConfig.workDayStartOn = this.config.workDayStartOn;
      this.config.lumenizeCalculatorConfig.workDayEndBefore = this.config.workDayEndBefore;
      this.config.lumenizeCalculatorConfig.holidays = this.config.holidays;
      this.config.lumenizeCalculatorConfig.workDays = this.config.workDays;
      return this.LumenizeCalculatorClass = lumenize.TimeInStateCalculator;
    };

    TIPVisualizer.prototype.onNewDataAvailable = function() {
      var queryConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.onNewDataAvailable');
      }
      queryConfig = {
        'X-RallyIntegrationName': 'TIP Chart (prototype)',
        'X-RallyIntegrationVendor': 'Rally Red Pill',
        'X-RallyIntegrationVersion': '0.2.0',
        workspaceOID: this.projectAndWorkspaceScope.workspaceOID
      };
      if (this.upToDateISOString == null) {
        this.upToDateISOString = '2011-12-01T00:00:00.000Z';
      }
      this.analyticsQuery = new TimeInStateAnalyticsQuery(queryConfig, this.upToDateISOString, this.config.statePredicate);
      if (this.projectAndWorkspaceScope.projectScopingDown) {
        this.analyticsQuery.scope('_ProjectHierarchy', this.projectAndWorkspaceScope.projectOID);
      } else {
        this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOID);
      }
      this.analyticsQuery.type(this.config.type).fields(this.config.toolTipFieldNames);
      if (this.config.leafOnly) {
        this.analyticsQuery.leafOnly();
      }
      if (this.config.asOf != null) {
        this.analyticsQuery.additionalCriteria({
          _ValidFrom: {
            $lt: this.getAsOfISOString()
          }
        });
      }
      if (this.config.debug) {
        this.analyticsQuery.debug();
        console.log('Requesting data...');
      }
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    TIPVisualizer.prototype.getHashForCache = function() {
      var hashObject, hashString, out, salt, userConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.getHashForCache');
      }
      hashObject = {};
      userConfig = utils.clone(this.userConfig);
      delete userConfig.debug;
      delete userConfig.daysToShow;
      delete userConfig.showStillInProgress;
      hashObject.userConfig = userConfig;
      hashObject.projectAndWorkspaceScope = this.projectAndWorkspaceScope;
      hashObject.workspaceConfiguration = this.workspaceConfiguration;
      salt = 'TIP v0.2.75';
      hashString = JSON.stringify(hashObject);
      out = md5(hashString + salt);
      return out;
    };

    TIPVisualizer.prototype.updateVisualizationData = function() {
      var asOfMilliseconds, b, bucketSize, buckets, calculatorResults, chartMax, clipped, endBeforeInMinutes, histogramCategories, histogramData, histogramResults, jsDateMilliseconds, millisecondsToShow, row, startMilliseconds, startOnInMinutes, timeInState, valueMax, workHours, workMinutes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      if (this.config.trace) {
        console.log('in TIPVisualizer.createOrUpdateVisualization');
      }
      calculatorResults = this.lumenizeCalculator.getResults();
      if (calculatorResults.length === 0) {
        this.visualizationData = null;
        return;
      }
      timeInState = [];
      if (this.config.asOf != null) {
        asOfMilliseconds = new lumenize.Time(this.config.asOf, 'millisecond').getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
      } else {
        asOfMilliseconds = new Date().getTime();
      }
      millisecondsToShow = this.userConfig.daysToShow * 1000 * 60 * 60 * 24;
      startMilliseconds = asOfMilliseconds - millisecondsToShow;
      for (_i = 0, _len = calculatorResults.length; _i < _len; _i++) {
        row = calculatorResults[_i];
        jsDateMilliseconds = new lumenize.Time(row._ValidTo_lastValue, 'millisecond').getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
        if (jsDateMilliseconds > asOfMilliseconds) {
          row.x = asOfMilliseconds;
        } else {
          row.x = jsDateMilliseconds;
        }
        row.x -= Math.random() * 1000 * 60 * 60;
        if (this.config.radiusField != null) {
          row.marker = {
            radius: this.config.radiusField.f(row[this.config.radiusField.field + "_lastValue"])
          };
        }
        if ((this.userConfig.showStillInProcess || jsDateMilliseconds < asOfMilliseconds) && jsDateMilliseconds > startMilliseconds) {
          timeInState.push(row);
        }
      }
      if (!(timeInState.length > 0)) {
        return;
      }
      startOnInMinutes = this.config.workDayStartOn.hour * 60;
      if ((_ref = this.config.workDayStartOn) != null ? _ref.minute : void 0) {
        startOnInMinutes += this.config.workDayStartOn.minute;
      }
      endBeforeInMinutes = this.config.workDayEndBefore.hour * 60;
      if ((_ref1 = this.config.workDayEndBefore) != null ? _ref1.minute : void 0) {
        endBeforeInMinutes += this.config.workDayEndBefore.minute;
      }
      if (startOnInMinutes < endBeforeInMinutes) {
        workMinutes = endBeforeInMinutes - startOnInMinutes;
      } else {
        workMinutes = 24 * 60 - startOnInMinutes;
        workMinutes += endBeforeInMinutes;
      }
      workHours = workMinutes / 60;
      for (_j = 0, _len1 = timeInState.length; _j < _len1; _j++) {
        row = timeInState[_j];
        row.days = row.ticks / workHours;
      }
      histogramResults = lumenize.histogram(timeInState, 'days');
      if (histogramResults == null) {
        return;
      }
      buckets = histogramResults.buckets, chartMax = histogramResults.chartMax, valueMax = histogramResults.valueMax, bucketSize = histogramResults.bucketSize, clipped = histogramResults.clipped;
      for (_k = 0, _len2 = timeInState.length; _k < _len2; _k++) {
        row = timeInState[_k];
        row.y = row.clippedChartValue;
      }
      if (this.config.debug) {
        console.log('timeInState just after calling histogram:');
        console.log(timeInState);
      }
      histogramCategories = [];
      histogramData = [];
      for (_l = 0, _len3 = buckets.length; _l < _len3; _l++) {
        b = buckets[_l];
        histogramCategories.push(b.label);
        histogramData.push(b.count);
      }
      return this.visualizationData = {
        timeInState: timeInState,
        histogramResults: histogramResults,
        histogramCategories: histogramCategories,
        histogramData: histogramData
      };
    };

    return TIPVisualizer;

  })(VisualizerBase);

  this.TIPVisualizer = TIPVisualizer;

}).call(this);
